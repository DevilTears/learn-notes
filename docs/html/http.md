# 浏览器原理问题

## 常见的http状态码和前端缓存

> 题目来源：2020.12 好未来

![http-code](./images/http-code.png)

- 200 ok（请求成功）
- 204 no content （请求成功，但是没有结果返回）
- 206 partial content （客户端请求一部分资源，服务端成功响应，返回一范围资源）
- 301 move permanently （永久性重定向）
- 302 found （临时性重定向）
- 303 see other （示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源）
- 304 not modified （表示在客户端采用带条件的访问某资源时，服务端找到了资源，但是这个请求的条件不符合。跟重定向无关）
- 307 temporary redirect （跟302一个意思）
- 400 bad request （请求报文存在语法错误）
- 401 unauthorized （需要认证（第一次返回）或者认证失败（第二次返回））
- 403 forbidden （请求被服务器拒绝了）
- 404 not found （服务器上无法找到请求的资源）
- 405 not allowed (请求方法错误)
- 500 internal server error （服务端执行请求时发生了错误）
- 503 service unavailable （服务器正在超负载或者停机维护，无法处理请求）

## 301和302的区别

> 题目来源：2020.12 好未来

302重定向只是暂时的重定向，搜索引擎会抓取新的内容而保留旧的地址，因为服务器返回302，所以，搜索搜索引擎认为新的网址是暂时的。而301重定向是永久的重定向，搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址。

## HTTP/2的三大特性, 与HTTP/1.1的区别

HTTP/2的三大特性: **头部压缩、Server Push、多路复用**

HTTP/2在HTTP/1.1有几处基本的不同:

- HTTP/2是二进制协议而不是文本协议。不再可读，也不可无障碍的手动创建，改善的优化技术现在可被实施。
- 这是一个复用协议。并行的请求能在同一个链接中处理，移除了HTTP/1.x中顺序和阻塞的约束。
- 压缩了headers。因为headers在一系列请求中常常是相似的，其移除了重复和传输重复数据的成本。
- 其允许服务器在客户端缓存中填充数据，通过一个叫服务器推送的机制来提前请求。

> 参考文献：
>
> 1. [MDN: HTTP/2](https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP_2)
> 2. [MDN: HTTP/2 - 为了更优异的表现](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP#http2_-_%E4%B8%BA%E4%BA%86%E6%9B%B4%E4%BC%98%E5%BC%82%E7%9A%84%E8%A1%A8%E7%8E%B0)

## 解决域名请求并发数量限制

浏览器使用并行连接，但它们将并行连接的总数限制为少量（通常为4，6个）

### HTTP 1.1情况下

Keep-Alive解决的核心问题：一定时间内，同一域名多次请求数据，只建立一次HTTP请求，其他请求可复用每一次建立的连接通道，以达到提高请求效率的问题。这里面所说的一定时间是可以配置的，不管你用的是Apache还是nginx。

如上面所说，在HTTP1.1中是默认开启了Keep-Alive，他解决了多次连接的问题，但是依然有两个效率上的问题：

- 第一个：串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是1秒，那么a文件用时为3秒，b文件传输完成用时为6秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）
- 第二个：连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。

综上所述：通古多域名提高浏览器的下载速度。将静态文件图片打到两个或多个域名，这样浏览器就可以对 n * 6 个文件进行同时下载，避免了浏览器6个通道的限制，这样做的缺点也是明显的，1.DNS的解析时间会变长。2.增加了服务器的压力。

### HTTP 2情况下

HTTP/2的多路复用就是为了解决上述的两个性能问题，我们来看一下，他是如何解决的。

- 解决第一个：在HTTP1.1的协议中，我们传输的request和response都是基本于文本的，这样就会引发一个问题：所有的数据必须按顺序传输，比如需要传输：hello world，只能从h到d一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序，所以并行传输在HTTP1.1是不能实现的。

![image](./images/http-1.png)

HTTP/2引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，如下图所示，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是流所做的事情。

![image](./images/http-2.png)

- 解决第二个问题：HTTP/2对同一域名下所有请求都是基于流，也就是说同一域名不管访问多少文件，也只建立一路连接。同样Apache的最大连接数为300，因为有了这个新特性，最大的并发就可以提升到300，比原来提升了6倍！

### 总结

有了HTTP/2之后，根据上面讲的原理，我们就不用这么搞了，成本会更低。

> 参考文献：
> [浅析HTTP/2的多路复用](https://segmentfault.com/a/1190000011172823?utm_source=tag-newest)

## HTTP1和HTTP1.1缓存上区别

> 题目来源：2020.12-好未来

HTTP/1.1在1.0的基础上加入了一些cache的新特性，当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活（revalidation）。

## HTTPS的原理，加密方式，非对称还是对称

> 题目来源：2020.12-好未来

HTTPS 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段。

HTTPS要保证客户端与服务器端的通信安全，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。

## HTTP和HTTPS的默认端口号

> 题目来源：2020.12-好未来

80, 443
